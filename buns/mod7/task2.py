"""
Декоратор-запоминатор - это особая функция,
которая принимает другую функцию в качестве аргумента
и возвращает новую функцию (оболочку), которая добавляет дополнительную функциональность к исходной функции.

В данном случае, задача состоит в том, чтобы создать декоратор memoize,
который будет запоминать результаты выполнения функции и возвращать их при повторном вызове функции с теми же аргументами.
Для этого используется мемоизация - сохранение результатов ресурсоемких вызовов и их возвращение
при повторении тех же входных данных.
"""

# создаем декоратор memoize, который принимает функцию в качестве аргумента и возвращает функцию-оболочку wrapper.

def memoize(func):
    cache = {}                        # Создаем пустой словарь для кэширования результатов

    def wrapper(*args):
        
        # Внутри оболочки мы проверяем, есть ли уже результат в кэше по данным аргументам.
        
        if args in cache:             # Если результат уже был кэширован
            return cache[args]        # возвращаем его
        # Если нет,
        result = func(*args)          # Вызываем декорируемую функцию
        cache[args] = result          # Сохраняем результат в кэше
        return result
    
    # чтобы декорированная функция сохраняла свое имя и документацию, копируем эти атрибуты из исходной функции в оболочку:
    wrapper.__name__ = func.__name__  # Сохраняем имя декорируемой функции
    wrapper.__doc__ = func.__doc__    # Сохраняем документацию декорируемой функции
    return wrapper                    # Возвращаем функцию-оболочку

# Пример использования декоратора memoize
# применяем этот декоратор к рекурсивной функции fibonacci, чтобы запоминать результаты ее выполнения.

@memoize
def fibonacci(n):                     # Когда функция fibonacci вызывается с определенным входным значением,
                                      # декоратор проверяет, был ли результат уже рассчитан и сохранен в кэше.
    if n < 2:                         # Если был, кэшированный результат возвращается немедленно.
        return n                      # Если нет, то будет вызвана функция fibonacci для вычисления результата,
    return fibonacci(n - 1) + fibonacci(n - 2)  # и результат будет сохранен в кэше для использования в будущем.

# Вызов функции с использованием декоратора
result = fibonacci(10)                # вызываем функцию fibonacci с аргументом 10 и сохраняем результат в переменную result.

print(result)                         # Затем выводим результат на экран.

